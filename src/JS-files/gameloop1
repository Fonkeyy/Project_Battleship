const computerLogic = (computerBoard, playerBoard) => {
    const computer = playerBoard.opponentName;

    if (computer.hitList.length) {
        // * Get last hit coords
        const lastHit = computer.hitList[computer.hitList.length - 1];
        const lastHitX = lastHit[0];
        const lastHitY = lastHit[1];
        // * Check if last hit has sunk the ship, if yes, empty possible moves list and recursively call computer logic
        if (playerBoard.board[lastHitY][lastHitX] === 3) {
            availableMoves = [];
            computer.hitList.pop();
            computerLogic(computerBoard, playerBoard);
            return;
        } else {
            // * If no possible moves in the list, find new ones

            if (availableMoves.length === 0) {
                // * Check if it's possible to attack above the last hit
                if (
                    lastHitY - 1 >= 0 &&
                    (playerBoard.board[lastHitY - 1][lastHitX] === false ||
                        playerBoard.board[lastHitY - 1][lastHitX] === 1 ||
                        playerBoard.matrix[lastHitY - 1][lastHitX] === false)
                ) {
                    availableMoves.push([lastHitX, lastHitY - 1]);
                }

                // * Check if it's possible to attack below the last hit
                if (
                    lastHitY + 1 <= 9 &&
                    (playerBoard.board[lastHitY + 1][lastHitX] === false ||
                        playerBoard.board[lastHitY + 1][lastHitX] === 1 ||
                        playerBoard.matrix[lastHitY + 1][lastHitX] === false)
                ) {
                    availableMoves.push([lastHitX, lastHitY + 1]);
                }

                // * Check if it's possible to attack to the left of the last hit
                if (
                    lastHitX - 1 >= 0 &&
                    (playerBoard.board[lastHitY][lastHitX - 1] === false ||
                        playerBoard.board[lastHitY][lastHitX - 1] === 1 ||
                        playerBoard.matrix[lastHitY][lastHitX - 1] === false)
                ) {
                    availableMoves.push([lastHitX - 1, lastHitY]);
                }

                // * Check if it's possible to attack to the right of the last hit
                if (
                    lastHitX + 1 <= 9 &&
                    (playerBoard.board[lastHitY][lastHitX + 1] === false ||
                        playerBoard.board[lastHitY][lastHitX + 1] === 1 ||
                        playerBoard.matrix[lastHitY][lastHitX + 1] === false)
                ) {
                    availableMoves.push([lastHitX + 1, lastHitY]);
                }
            }
            // * If possible moves choose 1 randomly then attack player board with it
            const chooseRandomMove = () => {
            if (availableMoves.length > 0) {
                // * Randomly choose one and attack opponent board with it
                const randomIndex = getRandomInteger(0, availableMoves.length - 1);
                const [nextX, nextY] = availableMoves[randomIndex];

                if (playerBoard.board[nextY][nextX] === false && playerBoard.matrix[nextY][nextX] === false) {
                    computer.attack([nextX, nextY], playerBoard);
                    // * Remove used move from possible moves
                    availableMoves.splice(randomIndex, 1);
                    if (!availableMoves) {
                        computer.hitList.pop();
                    }
                } else {
                    availableMoves.splice(randomIndex, 1);
                    if (!availableMoves) {
                        computer.hitList.pop();
                    }
                    chooseRandomMove()
                } else {
                    computer.randomAttack(playerBoard);
                }
            } else {
                computer.randomAttack(playerBoard);
            }
                    }
                    chooseRandomMove()
                }
    };
            }

// const computerLogic = (computerBoard, playerBoard) => {
//     const computer = playerBoard.opponentName;

//     // * Get last hit coords if there is one
//     if (computer.hitList.length) {
//         console.log(computer.hitList);
//         const lastHit = computer.hitList[computer.hitList.length - 1];
//         const lastHitX = lastHit[0];
//         const lastHitY = lastHit[1];

//         // * Check if last hit has sunk the ship, if yes, empty possible moves list and random attack
//         if (playerBoard.board[lastHitY][lastHitX] === 3) {
//             availableMoves = [];
//             computer.randomAttack(playerBoard);
//             return;
//             // * If no possible moves in the list, find new ones
//         } else {
//             if (availableMoves.length === 0) {
//                 // * Check if it's possible to attack above the last hit
//                 if (
//                     lastHitY - 1 >= 0 &&
//                     (playerBoard.board[lastHitY - 1][lastHitX] === false ||
//                         playerBoard.board[lastHitY - 1][lastHitX] === 1)
//                 ) {
//                     availableMoves.push([lastHitX, lastHitY - 1]);
//                 }

//                 // * Check if it's possible to attack below the last hit
//                 if (
//                     lastHitY + 1 <= 9 &&
//                     (playerBoard.board[lastHitY + 1][lastHitX] === false ||
//                         playerBoard.board[lastHitY + 1][lastHitX] === 1)
//                 ) {
//                     availableMoves.push([lastHitX, lastHitY + 1]);
//                 }

//                 // * Check if it's possible to attack to the left of the last hit
//                 if (
//                     lastHitX - 1 >= 0 &&
//                     (playerBoard.board[lastHitY][lastHitX - 1] === false ||
//                         playerBoard.board[lastHitY][lastHitX - 1] === 1)
//                 ) {
//                     availableMoves.push([lastHitX - 1, lastHitY]);
//                 }

//                 // * Check if it's possible to attack to the right of the last hit
//                 if (
//                     lastHitX + 1 <= 9 &&
//                     (playerBoard.board[lastHitY][lastHitX + 1] === false ||
//                         playerBoard.board[lastHitY][lastHitX + 1] === 1)
//                 ) {
//                     availableMoves.push([lastHitX + 1, lastHitY]);
//                 }
//             }
//             // * If possible moves choose 1 randomly then attack player board with it
//             if (availableMoves.length > 0) {
//                 // * Randomly choose one and attack opponent board with it
//                 const randomIndex = getRandomInteger(0, availableMoves.length - 1);
//                 console.table(availableMoves);
//                 const [nextX, nextY] = availableMoves[randomIndex];
//                 computer.attack([nextX, nextY], playerBoard);
//                 // * Remove used move from possible moves
//                 availableMoves.splice(randomIndex, 1);
//             } else {
//                 computer.randomAttack(playerBoard);
//             }
//         }
//     } else {
//         computer.randomAttack(playerBoard);
//     }
// };
